[{"title":"1460心得","path":"/2024/04/26/1460心得/","content":"XTU 1460 距离#题目描述n个在X轴上的点，存在m个区间，点可以安排在这些区间内，坐标为i,j的两个点的距离为|i−j|。 求这些点最小距离的最大值？ 比如有三个点，区间为[1,2],[3,4],[5,7]， 我们如果这三个点分别安排在1,3,7，这样最小距离为2；如果安排在1,4,7，这样最小距离为3。 这个例子中最小距离的最大值为3。 输入格式第一行是一个整数T(1≤T≤50)，表示样例的个数。 每个样例的第一行是两个整数n (2≤n≤10000)，m (1≤m≤10000)。 以后的m行，每行两个整数a,b, (1≤a&lt;b≤109)，表示整数点可以安排的区间。 输出格式每行输出一个样例的结果，如果为一个整数，那么输出整数；否则，输出一个分数，并保证分子与分母互质。 样例输入12345678923 31 23 45 73 11 2 样例输出1231/2 提示区间可能存在相交或者包含 个人思路及理解这题说实话有一点难崩，本来是一道程设光头题的，但是我想了2天后一下子过了3个人，果然还是我水平太差了，但是最后终于还是写出来了，心血来潮想写一份博客，纪念一下自己兴奋的心情 先贴上自己的c++AC代码 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879#include &lt;bits/stdc++.h&gt;using namespace std;const int N = 1e4 + 10, INF = 0x3f3f3f3f;const double eps = 1e-8;int n, m;vector&lt;pair&lt;int, int&gt;&gt; v;inline int read() &#123; int s = 0, w = 1; char ch = getchar(); while (ch &lt; &#x27;0&#x27; || ch &gt; &#x27;9&#x27;) &#123; if (ch == &#x27;-&#x27;) w = -1; ch = getchar(); &#125; while (ch &gt;= &#x27;0&#x27; &amp;&amp; ch &lt;= &#x27;9&#x27;) &#123; s = s * 10 + ch - &#x27;0&#x27;; ch = getchar(); &#125; return s * w;&#125;int GCD(int n, int m) &#123; return m == 0 ? n : GCD(m, n % m);&#125;void pr() &#123; sort(v.begin(), v.end()); vector&lt;pair&lt;int, int&gt;&gt; tmp; for (auto &amp; i : v) &#123; if (tmp.empty() || tmp.back().second &lt; i.first) tmp.emplace_back(i); else tmp.back().second = max(tmp.back().second, i.second); &#125; v = tmp;&#125;int check(double ans) &#123; int now = 0, num = 1; double point = v[0].first; while (num &lt; n &amp;&amp; now &lt; v.size()) &#123; if (v[now].second - point &gt; ans || fabs(v[now].second - point - ans) &lt; eps) &#123; if (v[now].first - point &gt;= ans) point = v[now].first; else point += ans; num++; &#125; else now++; &#125; return num &gt;= n;&#125;int main() &#123; int t = read(); while (t--) &#123; v.clear(); int a, b; n = read(); m = read(); for (int i = 0; i &lt; m; i++) &#123; a = read(); b = read(); if (a &gt; b) swap(a, b); v.emplace_back(a, b); &#125; pr(); double maxn = (double)(v.back().second - v.front().first) / (n - 1); double l = 0, r = maxn; while (r - l &gt; eps) &#123; double mid = l + (r - l) / 2; if (check(mid)) l = mid; else r = mid; &#125; int u = 0, d = 0; double mins = INF; for (int x = 1; x &lt; n; x++) &#123; if ((u == 0 &amp;&amp; d == 0) || abs((l * x) - round(l * x)) &lt; mins) &#123; mins = abs((l * x) - round(l * x)); u = round(l * x), d = x; &#125; &#125; int gcd = GCD(u, d); if (d == gcd) printf(&quot;%d &quot;, u / gcd); else printf(&quot;%d/%d &quot;, u / gcd, d / gcd); &#125; return 0;&#125; 推荐编译条件 -o2 -std&#x3D;c++11 整体思想不太难，主要就是输入区间以后做区间合并（可以不合并，但是会导致速度较慢），然后找到目前最大的可以放的长度：区间最左和最右，不考虑目前的中间缺项，然后从0到最大长度二分查找能够实现的最长的（最小的两数间距），最后枚举分母，并且计算最接近答案的相除的分子和分母 难点 二分的判断条件，怎么实现当前长度每一个点都能放在区间中 怎么合并区间，高效快速 怎么找到最合适的分子分母","tags":["程设"]},{"title":"数据库第四次作业","path":"/2024/04/24/数据库第四次作业/","content":"第四次作业4.1全部都是natural join， 会消去部分我们不希望消去的数据, 例如会导致instructor和course中dept_name项相对应的消除 4.2a123select distinct ID, (case when course_id is null then &#x27;0&#x27; else course_id end) coursesfrom instructor left join teaches using (ID); b123456789101112select ID, &#x27;0&#x27; coursesfrom instructorwhere ID in ( select ID from teaches right join instructor using (ID) group by ID having count(course_id) = 0)unionselect distinct ID, course_idfrom instructor natural join teachesorder by courses c12345678910select ( case when ID = null then &#x27;-&#x27; else ID end) t_id, ( case when name = null then &#x27;-&#x27; else name end) t_namefrom instructor natural join teaches right join section using(course_id, sec_id, semester, year)where semester = &#x27;Spring&#x27; and year = 2018; d123select dept_name, count(ID)from instructor right join department using(dept_name)group by dept_name; 4.5a假设有一位老师名字叫做James，插入以下数据 1234567891011121314instructor (00000, &#x27;James&#x27;, &#x27;Comp. Sci.&#x27;, 90000);teaches (00000, 100, 1, &#x27;Spring&#x27;, 2024);teaches (00000, 101, 1, &#x27;Spring&#x27;, 2024);teaches (00000, 102, 1, &#x27;Spring&#x27;, 2024);teaches (00000, 103, 1, &#x27;Spring&#x27;, 2024);teaches (00000, 104, 1, &#x27;Spring&#x27;, 2024);teaches (00000, 105, 1, &#x27;Spring&#x27;, 2024);course (100, &#x27;TestClass0&#x27;, &#x27;Biology&#x27;, 1);course (101, &#x27;TestClass1&#x27;, &#x27;Comp. Sci.&#x27;, 1);course (102, &#x27;TestClass2&#x27;, &#x27;Comp. Sci.&#x27;, 1);course (103, &#x27;TestClass3&#x27;, &#x27;Comp. Sci.&#x27;, 1);course (104, &#x27;TestClass4&#x27;, &#x27;Comp. Sci.&#x27;, 1);course (105, &#x27;TestClass5&#x27;, &#x27;Comp. Sci.&#x27;, 1);查询只有&#x27;TestClass0&#x27;，其他5门课都因为dept_name相同被消去了 b用于测试两个表之间的left outer join 和right outer join，如果所有值都是一样的，无论怎么连接都会有正确的结果，但是如果两个表都有对方没有的数据，就会出现空值，从而继续测试，能够找出错误 c用于测试outer join 和innner join， 当没有空值外键的时候，两个连接都是一样的，无法判断，但是当有空值外键的时候，能够测试出outerjoin和innerjoin的区别 4.6提前插入 null 0 到grade_points表里面 12select ID, sum(points) / count(ID) GPA from student natural join takes natural join grade_points group by ID; 4.712345678910employee :\tprimary key (ID),works : primary key (ID), foreign key (ID) references employee, foreign key (company_name) references company on delete cascadecompany:\tprimary key (company_name)manages:\tprimary key (ID), foreign key (ID) references employee, foreign key (manager_id) references employee(ID) on delete cascade 4.8a12345select ID, semester, sec_idfrom instructor natural join teaches join section using(course_id, semester, year, sec_id)group by ID, semester, sec_idhaving count(building) &gt;= 2; b1234567create assertion teacher_check check (\tselect ID, semester, sec_id from instructor natural join teaches join section using(course_id, semester, year, sec_id) group by ID, semester, sec_id having count(building) &lt; 2;) 4.9因为on delete cascade的原因，当表中一个元组被删除时，会导致引用其的所有元组皆被级联删除，即：当manager中一个元组被删除的时候，employee_ID作为manager_ID对应的employee_id也会被删除，也就是说a员工被删除的时候，a员工所领导的b员工也会被删除，假设b员工也领导了c员工，那么就会引起连锁反应，一下删除大量关系，只有与这些员工完全没有联系的其他员工不会被删除。 4.14因为takes和student和section三个表格中，只有takes和student的相同项：ID 还有takes和section的相同项：course_id, semester, year, sec_id，没有额外重复的元素，不会导致过度减少元组，同时使用的where语句，group by语句，having语句与添加的section表也没有冲突，不会到hi结果的改变 4.1512select *from section join classroom using (building, room_number); 4.161234select ID from student left join takes using (ID)group by IDhaving count(course_id) = 0; 4.171234select *from student left outer join advisoron ID = s_IDwhere i_id is not null; 4.181234select IDfrom employee left join manages using(ID)group by ID having count(manager_id) = 0; 4.201234567create tot_credits (\tyear numeric(4, 0), num_credits numeric(4, 0), primary key (year, num_credits), foreign key (year) references takes(year) on delete cascade); 4.24会，首先A有授权特权，能够授权他人，其次，A使用了grant option 将r上的选择权力授权给了公众，这下所有人都有选择的权力，并且他们能继续将权力授权给他人，现在B重新授权给A，相当于A给了自己grant option 的选择权力，会导致出现环路","tags":["数据库"]}]